import pytest
import asyncio
from datetime import datetime
import os
import tempfile
from unittest.mock import patch, MagicMock

from ..models.vulnerability import Vulnerability, SeverityLevel
from ..models.vulnerability_database import (
    VulnerabilityDatabaseEntry,
    VulnerabilityDatabaseQuery,
    VulnerabilityStatus,
    VulnerabilitySource
)
from ..services.vulnerability_database import VulnerabilityDatabase

@pytest.fixture
def temp_db_path():
    """Create a temporary database file path"""
    fd, path = tempfile.mkstemp()
    os.close(fd)
    yield path
    os.unlink(path)

@pytest.fixture
def sample_vulnerability():
    """Create a sample vulnerability for testing"""
    return Vulnerability(
        id="CVE-2023-12345",
        title="Test Vulnerability",
        description="This is a test vulnerability",
        severity=SeverityLevel.HIGH,
        cvss_score=8.5,
        affected_component="test-package@1.0.0",
        fix_version="1.1.0",
        references=["https://example.com/cve-2023-12345"]
    )

@pytest.fixture
def sample_db_entry(sample_vulnerability):
    """Create a sample database entry for testing"""
    return VulnerabilityDatabaseEntry(
        vulnerability=sample_vulnerability,
        sources=[VulnerabilitySource.NVD],
        status=VulnerabilityStatus.ACTIVE,
        affected_versions=["1.0.0"],
        fixed_versions=["1.1.0"],
        published_date=datetime.utcnow(),
        last_updated=datetime.utcnow(),
        cwe_ids=["CWE-79"],
        tags={"xss", "web"},
        notes="Test notes"
    )

@pytest.mark.asyncio
async def test_initialize_database(temp_db_path):
    """Test database initialization"""
    db = VulnerabilityDatabase(db_path=temp_db_path)
    
    # Check if database file was created
    assert os.path.exists(temp_db_path)
    
    # Check if tables were created
    import sqlite3
    conn = sqlite3.connect(temp_db_path)
    cursor = conn.cursor()
    
    # Check vulnerabilities table
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='vulnerabilities'")
    assert cursor.fetchone() is not None
    
    # Check database_updates table
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='database_updates'")
    assert cursor.fetchone() is not None
    
    conn.close()

@pytest.mark.asyncio
async def test_add_and_get_vulnerability(temp_db_path, sample_db_entry):
    """Test adding and retrieving a vulnerability"""
    db = VulnerabilityDatabase(db_path=temp_db_path)
    
    # Add vulnerability
    await db.add_custom_vulnerability(sample_db_entry)
    
    # Get vulnerability
    retrieved = await db.get_vulnerability(sample_db_entry.vulnerability.id)
    
    # Check if retrieved vulnerability matches the original
    assert retrieved is not None
    assert retrieved.vulnerability.id == sample_db_entry.vulnerability.id
    assert retrieved.vulnerability.title == sample_db_entry.vulnerability.title
    assert retrieved.vulnerability.severity == sample_db_entry.vulnerability.severity
    assert retrieved.status == sample_db_entry.status

@pytest.mark.asyncio
async def test_search_vulnerabilities(temp_db_path, sample_db_entry):
    """Test searching for vulnerabilities"""
    db = VulnerabilityDatabase(db_path=temp_db_path)
    
    # Add vulnerability
    await db.add_custom_vulnerability(sample_db_entry)
    
    # Search by CVE ID
    query = VulnerabilityDatabaseQuery(cve_id="CVE-2023-12345")
    results = await db.search_vulnerabilities(query)
    assert len(results) == 1
    assert results[0].vulnerability.id == sample_db_entry.vulnerability.id
    
    # Search by component
    query = VulnerabilityDatabaseQuery(component="test-package")
    results = await db.search_vulnerabilities(query)
    assert len(results) == 1
    
    # Search by severity
    query = VulnerabilityDatabaseQuery(severity=[SeverityLevel.HIGH])
    results = await db.search_vulnerabilities(query)
    assert len(results) == 1
    
    # Search by status
    query = VulnerabilityDatabaseQuery(status=[VulnerabilityStatus.ACTIVE])
    results = await db.search_vulnerabilities(query)
    assert len(results) == 1
    
    # Search by text
    query = VulnerabilityDatabaseQuery(text_search="test")
    results = await db.search_vulnerabilities(query)
    assert len(results) == 1
    
    # Search with no matches
    query = VulnerabilityDatabaseQuery(text_search="nonexistent")
    results = await db.search_vulnerabilities(query)
    assert len(results) == 0

@pytest.mark.asyncio
async def test_update_vulnerability_status(temp_db_path, sample_db_entry):
    """Test updating vulnerability status"""
    db = VulnerabilityDatabase(db_path=temp_db_path)
    
    # Add vulnerability
    await db.add_custom_vulnerability(sample_db_entry)
    
    # Update status
    success = await db.update_vulnerability_status(
        sample_db_entry.vulnerability.id,
        VulnerabilityStatus.FIXED,
        "Fixed in version 1.1.0"
    )
    assert success
    
    # Get updated vulnerability
    updated = await db.get_vulnerability(sample_db_entry.vulnerability.id)
    assert updated.status == VulnerabilityStatus.FIXED
    assert updated.notes == "Fixed in version 1.1.0"

@pytest.mark.asyncio
async def test_get_database_stats(temp_db_path, sample_db_entry):
    """Test getting database statistics"""
    db = VulnerabilityDatabase(db_path=temp_db_path)
    
    # Add vulnerability
    await db.add_custom_vulnerability(sample_db_entry)
    
    # Get stats
    stats = await db.get_database_stats()
    
    # Check stats
    assert stats.total_entries == 1
    assert stats.by_severity[SeverityLevel.HIGH] == 1
    assert stats.by_status[VulnerabilityStatus.ACTIVE] == 1
    assert stats.by_source[VulnerabilitySource.NVD] == 1

@pytest.mark.asyncio
@patch('aiohttp.ClientSession.get')
@patch('aiohttp.ClientSession.post')
async def test_update_from_nvd(mock_post, mock_get, temp_db_path):
    """Test updating from NVD"""
    # Mock NVD API response
    mock_response = MagicMock()
    mock_response.status = 200
    mock_response.__aenter__.return_value = mock_response
    
    # Sample NVD data
    nvd_data = {
        "vulnerabilities": [
            {
                "cve": {
                    "id": "CVE-2023-54321",
                    "vulnStatus": "Analyzed",
                    "descriptions": [
                        {
                            "lang": "en",
                            "value": "Test vulnerability from NVD"
                        }
                    ],
                    "metrics": {
                        "cvssMetricV31": [
                            {
                                "cvssData": {
                                    "baseScore": 9.1,
                                    "exploitabilityScore": 3.9,
                                    "impactScore": 5.2
                                }
                            }
                        ]
                    },
                    "references": [
                        {
                            "url": "https://nvd.nist.gov/vuln/detail/CVE-2023-54321"
                        }
                    ],
                    "weaknesses": [
                        {
                            "description": [
                                {
                                    "lang": "en",
                                    "value": "CWE-79"
                                }
                            ]
                        }
                    ],
                    "published": "2023-01-01T00:00:00Z",
                    "lastModified": "2023-01-02T00:00:00Z"
                }
            }
        ]
    }
    
    mock_response.json.return_value = nvd_data
    mock_get.return_value = mock_response
    
    # Create database
    db = VulnerabilityDatabase(db_path=temp_db_path)
    
    # Update from NVD
    result = await db._update_from_nvd()
    
    # Check result
    assert result["status"] == "success"
    assert result["count"] == 1
    
    # Check if vulnerability was added
    vuln = await db.get_vulnerability("CVE-2023-54321")
    assert vuln is not None
    assert vuln.vulnerability.title == "Analyzed"
    assert vuln.vulnerability.severity == SeverityLevel.CRITICAL
    assert vuln.sources == [VulnerabilitySource.NVD]

@pytest.mark.asyncio
@patch('aiohttp.ClientSession.post')
async def test_update_from_github(mock_post, temp_db_path):
    """Test updating from GitHub"""
    # Mock GitHub API response
    mock_response = MagicMock()
    mock_response.status = 200
    mock_response.__aenter__.return_value = mock_response
    
    # Sample GitHub data
    github_data = {
        "data": {
            "securityAdvisories": {
                "nodes": [
                    {
                        "ghsaId": "GHSA-1234-5678-9012",
                        "summary": "Test GitHub Advisory",
                        "description": "This is a test GitHub advisory",
                        "severity": "HIGH",
                        "cvss": {
                            "score": 8.2,
                            "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
                        },
                        "identifiers": [
                            {
                                "type": "CVE",
                                "value": "CVE-2023-98765"
                            }
                        ],
                        "references": [
                            {
                                "url": "https://github.com/advisories/GHSA-1234-5678-9012"
                            }
                        ],
                        "publishedAt": "2023-02-01T00:00:00Z",
                        "updatedAt": "2023-02-02T00:00:00Z",
                        "vulnerabilities": {
                            "nodes": [
                                {
                                    "package": {
                                        "name": "test-package",
                                        "ecosystem": "npm"
                                    },
                                    "firstPatchedVersion": {
                                        "identifier": "1.2.0"
                                    },
                                    "vulnerableVersionRange": ">= 1.0.0, < 1.2.0"
                                }
                            ]
                        }
                    }
                ]
            }
        }
    }
    
    mock_response.json.return_value = github_data
    mock_post.return_value = mock_response
    
    # Create database
    db = VulnerabilityDatabase(db_path=temp_db_path)
    
    # Update from GitHub
    result = await db._update_from_github()
    
    # Check result
    assert result["status"] == "success"
    assert result["count"] == 1
    
    # Check if vulnerability was added
    vuln = await db.get_vulnerability("CVE-2023-98765")
    assert vuln is not None
    assert vuln.vulnerability.title == "Test GitHub Advisory"
    assert vuln.vulnerability.severity == SeverityLevel.HIGH
    assert vuln.vulnerability.affected_component == "npm:test-package"
    assert vuln.vulnerability.fix_version == "1.2.0"
    assert VulnerabilitySource.GITHUB in vuln.sources

@pytest.mark.asyncio
@patch('aiohttp.ClientSession.get')
async def test_update_from_snyk(mock_get, temp_db_path):
    """Test updating from Snyk"""
    # Mock Snyk API response
    mock_response = MagicMock()
    mock_response.status = 200
    mock_response.__aenter__.return_value = mock_response
    
    # Sample Snyk data
    snyk_data = {
        "SNYK-JS-TESTPACKAGE-123456": {
            "title": "Test Snyk Vulnerability",
            "description": "This is a test Snyk vulnerability",
            "severity": "high",
            "cvssScore": 7.5,
            "package": "test-package",
            "identifiers": {
                "CVE": ["CVE-2023-87654"],
                "CWE": ["CWE-79"]
            },
            "references": {
                "url": ["https://snyk.io/vuln/SNYK-JS-TESTPACKAGE-123456"]
            },
            "fixedIn": ["1.3.0"],
            "semver": {
                "vulnerable": [">=1.0.0 <1.3.0"]
            },
            "publicationTime": "2023-03-01T00:00:00Z",
            "modificationTime": "2023-03-02T00:00:00Z"
        }
    }
    
    mock_response.json.return_value = snyk_data
    mock_get.return_value = mock_response
    
    # Create database
    db = VulnerabilityDatabase(db_path=temp_db_path)
    
    # Update from Snyk
    result = await db._update_from_snyk()
    
    # Check result
    assert result["status"] == "success"
    assert result["count"] == 1
    
    # Check if vulnerability was added
    vuln = await db.get_vulnerability("CVE-2023-87654")
    assert vuln is not None
    assert vuln.vulnerability.title == "Test Snyk Vulnerability"
    assert vuln.vulnerability.severity == SeverityLevel.HIGH
    assert vuln.vulnerability.affected_component == "test-package"
    assert vuln.vulnerability.fix_version == "1.3.0"
    assert VulnerabilitySource.SNYK in vuln.sources
