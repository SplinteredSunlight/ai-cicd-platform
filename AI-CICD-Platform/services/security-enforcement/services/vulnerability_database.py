import os
import json
import aiohttp
import asyncio
import structlog
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Union, Set
import sqlite3
from pathlib import Path
import time
import re

from ..config import get_settings
from ..models.vulnerability import Vulnerability, SeverityLevel
from ..models.vulnerability_database import (
    VulnerabilityDatabaseEntry,
    VulnerabilityDatabaseStats,
    VulnerabilityDatabaseQuery,
    VulnerabilitySource,
    VulnerabilityStatus
)
from .cve_mitre_integration import CVEMitreIntegration
from .osv_integration import OSVIntegration
from .vulndb_integration import VulnDBIntegration

logger = structlog.get_logger()

class VulnerabilityDatabase:
    """
    Service for managing and querying vulnerability data from multiple sources
    """
    def __init__(self, db_path: Optional[str] = None):
        self.settings = get_settings()
        self.db_path = db_path or os.path.join(
            self.settings.artifact_storage_path,
            "vulnerability_database.sqlite"
        )
        self.last_update = None
        self.update_lock = asyncio.Lock()
        self.initialize_database()
        
    def initialize_database(self):
        """Initialize the SQLite database schema"""
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Create tables
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS vulnerabilities (
            id TEXT PRIMARY KEY,
            title TEXT NOT NULL,
            description TEXT NOT NULL,
            severity TEXT NOT NULL,
            cvss_score REAL NOT NULL,
            affected_component TEXT NOT NULL,
            fix_version TEXT,
            references TEXT,
            sources TEXT NOT NULL,
            status TEXT NOT NULL,
            affected_versions TEXT,
            fixed_versions TEXT,
            discovered_date TEXT,
            published_date TEXT,
            last_updated TEXT NOT NULL,
            exploitability_score REAL,
            impact_score REAL,
            cwe_ids TEXT,
            tags TEXT,
            notes TEXT,
            metadata TEXT
        )
        ''')
        
        # Create indexes for common queries
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_vuln_severity ON vulnerabilities(severity)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_vuln_component ON vulnerabilities(affected_component)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_vuln_status ON vulnerabilities(status)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_vuln_published ON vulnerabilities(published_date)')
        
        # Create update tracking table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS database_updates (
            source TEXT NOT NULL,
            last_update TEXT NOT NULL,
            status TEXT NOT NULL,
            metadata TEXT
        )
        ''')
        
        conn.commit()
        conn.close()
        
    async def update_database(self, sources: List[VulnerabilitySource] = None, force: bool = False) -> Dict:
        """
        Update the vulnerability database from specified sources
        """
        async with self.update_lock:
            if not force:
                # Check if update is needed based on configured interval
                if self.last_update and (datetime.utcnow() - self.last_update).total_seconds() < self.settings.vuln_db_update_interval:
                    return {"status": "skipped", "reason": "Update interval not reached"}
            
            sources = sources or list(VulnerabilitySource)
            update_tasks = []
            
            # Create update tasks for each source
            for source in sources:
                if source == VulnerabilitySource.NVD:
                    update_tasks.append(self._update_from_nvd())
                elif source == VulnerabilitySource.GITHUB:
                    update_tasks.append(self._update_from_github())
                elif source == VulnerabilitySource.SNYK:
                    update_tasks.append(self._update_from_snyk())
                elif source == VulnerabilitySource.OSINT:
                    update_tasks.append(self._update_from_osint())
                # Add other sources as needed
            
            # Run updates concurrently
            results = await asyncio.gather(*update_tasks, return_exceptions=True)
            
            # Process results
            update_stats = {}
            for i, result in enumerate(results):
                source = sources[i]
                if isinstance(result, Exception):
                    logger.error(f"Error updating from {source}", error=str(result))
                    update_stats[source] = {"status": "error", "error": str(result)}
                else:
                    update_stats[source] = result
            
            self.last_update = datetime.utcnow()
            
            # Update the database_updates table
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            for source, stats in update_stats.items():
                cursor.execute(
                    "INSERT OR REPLACE INTO database_updates VALUES (?, ?, ?, ?)",
                    (
                        source,
                        self.last_update.isoformat(),
                        stats.get("status", "unknown"),
                        json.dumps(stats)
                    )
                )
            
            conn.commit()
            conn.close()
            
            return {
                "status": "success",
                "timestamp": self.last_update.isoformat(),
                "sources": update_stats
            }
    
    async def _update_from_nvd(self) -> Dict:
        """
        Update vulnerability database from NVD (National Vulnerability Database)
        """
        try:
            # Get the last update time for NVD
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT last_update FROM database_updates WHERE source = ?", (VulnerabilitySource.NVD,))
            row = cursor.fetchone()
            conn.close()
            
            last_update = datetime.fromisoformat(row[0]) if row else datetime.utcnow() - timedelta(days=30)
            
            # Format date for NVD API
            modified_start_date = last_update.strftime("%Y-%m-%dT%H:%M:%S:000 UTC-00:00")
            
            # NVD API endpoint
            api_url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?lastModStartDate={modified_start_date}"
            
            # Fetch data from NVD
            async with aiohttp.ClientSession() as session:
                async with session.get(api_url) as response:
                    if response.status != 200:
                        return {"status": "error", "message": f"NVD API returned status {response.status}"}
                    
                    data = await response.json()
                    
                    # Process vulnerabilities
                    vulnerabilities = []
                    for item in data.get("vulnerabilities", []):
                        cve = item.get("cve", {})
                        
                        # Extract CVE ID
                        cve_id = cve.get("id")
                        if not cve_id:
                            continue
                        
                        # Extract metrics
                        metrics = cve.get("metrics", {})
                        cvss_v3 = metrics.get("cvssMetricV31", [{}])[0].get("cvssData", {})
                        cvss_v2 = metrics.get("cvssMetricV2", [{}])[0].get("cvssData", {})
                        
                        # Use CVSS v3 if available, otherwise v2
                        cvss_data = cvss_v3 or cvss_v2 or {}
                        
                        # Map severity
                        base_score = cvss_data.get("baseScore", 0)
                        severity = SeverityLevel.UNKNOWN
                        if base_score >= 9.0:
                            severity = SeverityLevel.CRITICAL
                        elif base_score >= 7.0:
                            severity = SeverityLevel.HIGH
                        elif base_score >= 4.0:
                            severity = SeverityLevel.MEDIUM
                        elif base_score > 0:
                            severity = SeverityLevel.LOW
                        
                        # Extract descriptions
                        descriptions = cve.get("descriptions", [])
                        description = next((d.get("value", "") for d in descriptions if d.get("lang") == "en"), "")
                        
                        # Extract references
                        references = [ref.get("url", "") for ref in cve.get("references", [])]
                        
                        # Extract CWE IDs
                        cwe_ids = []
                        for weakness in cve.get("weaknesses", []):
                            for desc in weakness.get("description", []):
                                if desc.get("lang") == "en" and desc.get("value", "").startswith("CWE-"):
                                    cwe_ids.append(desc.get("value"))
                        
                        # Create vulnerability entry
                        vuln = Vulnerability(
                            id=cve_id,
                            title=cve.get("vulnStatus", ""),
                            description=description,
                            severity=severity,
                            cvss_score=base_score,
                            affected_component="", # NVD doesn't provide this directly
                            references=references
                        )
                        
                        # Create database entry
                        entry = VulnerabilityDatabaseEntry(
                            vulnerability=vuln,
                            sources=[VulnerabilitySource.NVD],
                            status=VulnerabilityStatus.ACTIVE,
                            published_date=datetime.fromisoformat(cve.get("published", "").replace("Z", "+00:00")),
                            last_updated=datetime.fromisoformat(cve.get("lastModified", "").replace("Z", "+00:00")),
                            cwe_ids=cwe_ids,
                            exploitability_score=cvss_data.get("exploitabilityScore"),
                            impact_score=cvss_data.get("impactScore")
                        )
                        
                        vulnerabilities.append(entry)
                    
                    # Save to database
                    await self._save_vulnerabilities(vulnerabilities)
                    
                    return {
                        "status": "success",
                        "count": len(vulnerabilities),
                        "source": VulnerabilitySource.NVD
                    }
        
        except Exception as e:
            logger.error("Error updating from NVD", error=str(e))
            return {"status": "error", "message": str(e)}
    
    async def _update_from_github(self) -> Dict:
        """
        Update vulnerability database from GitHub Security Advisories
        """
        try:
            # Get the last update time for GitHub
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT last_update FROM database_updates WHERE source = ?", (VulnerabilitySource.GITHUB,))
            row = cursor.fetchone()
            conn.close()
            
            last_update = datetime.fromisoformat(row[0]) if row else datetime.utcnow() - timedelta(days=30)
            
            # GitHub Security Advisories API endpoint
            api_url = "https://api.github.com/graphql"
            
            # GraphQL query for security advisories
            query = """
            query {
                securityAdvisories(first: 100, orderBy: {field: PUBLISHED_AT, direction: DESC}) {
                    nodes {
                        ghsaId
                        summary
                        description
                        severity
                        cvss {
                            score
                            vectorString
                        }
                        identifiers {
                            type
                            value
                        }
                        references {
                            url
                        }
                        publishedAt
                        updatedAt
                        vulnerabilities(first: 10) {
                            nodes {
                                package {
                                    name
                                    ecosystem
                                }
                                firstPatchedVersion {
                                    identifier
                                }
                                vulnerableVersionRange
                            }
                        }
                    }
                }
            }
            """
            
            # GitHub API token from settings
            headers = {
                "Authorization": f"Bearer {self.settings.github_token}",
                "Content-Type": "application/json"
            }
            
            # Fetch data from GitHub
            async with aiohttp.ClientSession() as session:
                async with session.post(api_url, json={"query": query}, headers=headers) as response:
                    if response.status != 200:
                        return {"status": "error", "message": f"GitHub API returned status {response.status}"}
                    
                    data = await response.json()
                    advisories = data.get("data", {}).get("securityAdvisories", {}).get("nodes", [])
                    
                    # Process vulnerabilities
                    vulnerabilities = []
                    for advisory in advisories:
                        # Skip if published before last update
                        published_at = datetime.fromisoformat(advisory.get("publishedAt", "").replace("Z", "+00:00"))
                        if published_at < last_update:
                            continue
                        
                        # Extract CVE ID if available
                        cve_id = None
                        for identifier in advisory.get("identifiers", []):
                            if identifier.get("type") == "CVE":
                                cve_id = identifier.get("value")
                                break
                        
                        # Skip if no CVE ID and no vulnerabilities
                        if not cve_id and not advisory.get("vulnerabilities", {}).get("nodes"):
                            continue
                        
                        # Map severity
                        severity_map = {
                            "CRITICAL": SeverityLevel.CRITICAL,
                            "HIGH": SeverityLevel.HIGH,
                            "MODERATE": SeverityLevel.MEDIUM,
                            "LOW": SeverityLevel.LOW
                        }
                        severity = severity_map.get(advisory.get("severity"), SeverityLevel.UNKNOWN)
                        
                        # Extract references
                        references = [ref.get("url") for ref in advisory.get("references", [])]
                        
                        # Process each vulnerable package
                        for vuln in advisory.get("vulnerabilities", {}).get("nodes", []):
                            package = vuln.get("package", {})
                            package_name = package.get("name", "")
                            ecosystem = package.get("ecosystem", "")
                            
                            # Skip if no package info
                            if not package_name:
                                continue
                            
                            # Extract fix version
                            fix_version = vuln.get("firstPatchedVersion", {}).get("identifier")
                            
                            # Extract affected versions
                            affected_versions = []
                            version_range = vuln.get("vulnerableVersionRange", "")
                            if version_range:
                                # Simple parsing of version ranges like ">= 1.0.0, < 2.0.0"
                                affected_versions = [version_range]
                            
                            # Create vulnerability entry
                            vuln_id = cve_id or advisory.get("ghsaId")
                            vuln = Vulnerability(
                                id=vuln_id,
                                title=advisory.get("summary", ""),
                                description=advisory.get("description", ""),
                                severity=severity,
                                cvss_score=advisory.get("cvss", {}).get("score", 0.0),
                                affected_component=f"{ecosystem}:{package_name}",
                                fix_version=fix_version,
                                references=references
                            )
                            
                            # Create database entry
                            entry = VulnerabilityDatabaseEntry(
                                vulnerability=vuln,
                                sources=[VulnerabilitySource.GITHUB],
                                status=VulnerabilityStatus.ACTIVE,
                                affected_versions=affected_versions,
                                fixed_versions=[fix_version] if fix_version else [],
                                published_date=published_at,
                                last_updated=datetime.fromisoformat(advisory.get("updatedAt", "").replace("Z", "+00:00"))
                            )
                            
                            vulnerabilities.append(entry)
                    
                    # Save to database
                    await self._save_vulnerabilities(vulnerabilities)
                    
                    return {
                        "status": "success",
                        "count": len(vulnerabilities),
                        "source": VulnerabilitySource.GITHUB
                    }
        
        except Exception as e:
            logger.error("Error updating from GitHub", error=str(e))
            return {"status": "error", "message": str(e)}
    
    async def _update_from_snyk(self) -> Dict:
        """
        Update vulnerability database from Snyk Vulnerability Database
        """
        try:
            # Check if Snyk API key is configured
            if not self.settings.snyk_api_key:
                return {"status": "error", "message": "Snyk API key not configured"}
            
            # Get the last update time for Snyk
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT last_update FROM database_updates WHERE source = ?", (VulnerabilitySource.SNYK,))
            row = cursor.fetchone()
            conn.close()
            
            last_update = datetime.fromisoformat(row[0]) if row else datetime.utcnow() - timedelta(days=30)
            
            # Snyk API endpoint for vulnerabilities
            api_url = "https://snyk.io/api/v1/vulns"
            
            # Snyk API headers
            headers = {
                "Authorization": f"token {self.settings.snyk_api_key}",
                "Content-Type": "application/json"
            }
            
            # Fetch data from Snyk
            async with aiohttp.ClientSession() as session:
                async with session.get(api_url, headers=headers) as response:
                    if response.status != 200:
                        return {"status": "error", "message": f"Snyk API returned status {response.status}"}
                    
                    data = await response.json()
                    
                    # Process vulnerabilities
                    vulnerabilities = []
                    for vuln_id, vuln_data in data.items():
                        # Skip if published before last update
                        published_date = datetime.fromisoformat(vuln_data.get("publicationTime", "").replace("Z", "+00:00"))
                        if published_date < last_update:
                            continue
                        
                        # Map severity
                        severity_map = {
                            "critical": SeverityLevel.CRITICAL,
                            "high": SeverityLevel.HIGH,
                            "medium": SeverityLevel.MEDIUM,
                            "low": SeverityLevel.LOW
                        }
                        severity = severity_map.get(vuln_data.get("severity", "").lower(), SeverityLevel.UNKNOWN)
                        
                        # Extract package info
                        package = vuln_data.get("package", "")
                        
                        # Extract CVE IDs
                        identifiers = vuln_data.get("identifiers", {})
                        cve_ids = identifiers.get("CVE", [])
                        cve_id = cve_ids[0] if cve_ids else vuln_id
                        
                        # Extract references
                        references = []
                        for ref_type, ref_urls in vuln_data.get("references", {}).items():
                            if isinstance(ref_urls, list):
                                references.extend(ref_urls)
                        
                        # Extract fix version
                        fix_version = None
                        for version in vuln_data.get("fixedIn", []):
                            if version != "0.0.0":
                                fix_version = version
                                break
                        
                        # Create vulnerability entry
                        vuln = Vulnerability(
                            id=cve_id,
                            title=vuln_data.get("title", ""),
                            description=vuln_data.get("description", ""),
                            severity=severity,
                            cvss_score=vuln_data.get("cvssScore", 0.0),
                            affected_component=package,
                            fix_version=fix_version,
                            references=references
                        )
                        
                        # Create database entry
                        entry = VulnerabilityDatabaseEntry(
                            vulnerability=vuln,
                            sources=[VulnerabilitySource.SNYK],
                            status=VulnerabilityStatus.ACTIVE,
                            affected_versions=vuln_data.get("semver", {}).get("vulnerable", []),
                            fixed_versions=[fix_version] if fix_version else [],
                            published_date=published_date,
                            last_updated=datetime.fromisoformat(vuln_data.get("modificationTime", "").replace("Z", "+00:00")),
                            cwe_ids=vuln_data.get("identifiers", {}).get("CWE", [])
                        )
                        
                        vulnerabilities.append(entry)
                    
                    # Save to database
                    await self._save_vulnerabilities(vulnerabilities)
                    
                    return {
                        "status": "success",
                        "count": len(vulnerabilities),
                        "source": VulnerabilitySource.SNYK
                    }
        
        except Exception as e:
            logger.error("Error updating from Snyk", error=str(e))
            return {"status": "error", "message": str(e)}
    
    async def _save_vulnerabilities(self, entries: List[VulnerabilityDatabaseEntry]):
        """
        Save vulnerability entries to the database
        """
        if not entries:
            return
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        for entry in entries:
            vuln = entry.vulnerability
            
            # Convert lists and dicts to JSON strings
            references = json.dumps(vuln.references)
            sources = json.dumps([s.value for s in entry.sources])
            affected_versions = json.dumps(entry.affected_versions)
            fixed_versions = json.dumps(entry.fixed_versions)
            cwe_ids = json.dumps(entry.cwe_ids)
            tags = json.dumps(list(entry.tags))
            metadata = json.dumps(entry.metadata)
            
            # Convert dates to ISO format strings
            discovered_date = entry.discovered_date.isoformat() if entry.discovered_date else None
            published_date = entry.published_date.isoformat() if entry.published_date else None
            last_updated = entry.last_updated.isoformat()
            
            # Check if vulnerability already exists
            cursor.execute("SELECT id FROM vulnerabilities WHERE id = ?", (vuln.id,))
            exists = cursor.fetchone()
            
            if exists:
                # Update existing entry
                cursor.execute('''
                UPDATE vulnerabilities SET
                    title = ?,
                    description = ?,
                    severity = ?,
                    cvss_score = ?,
                    affected_component = ?,
                    fix_version = ?,
                    references = ?,
                    sources = ?,
                    status = ?,
                    affected_versions = ?,
                    fixed_versions = ?,
                    discovered_date = ?,
                    published_date = ?,
                    last_updated = ?,
                    exploitability_score = ?,
                    impact_score = ?,
                    cwe_ids = ?,
                    tags = ?,
                    notes = ?,
                    metadata = ?
                WHERE id = ?
                ''', (
                    vuln.title,
                    vuln.description,
                    vuln.severity.value,
                    vuln.cvss_score,
                    vuln.affected_component,
                    vuln.fix_version,
                    references,
                    sources,
                    entry.status.value,
                    affected_versions,
                    fixed_versions,
                    discovered_date,
                    published_date,
                    last_updated,
                    entry.exploitability_score,
                    entry.impact_score,
                    cwe_ids,
                    tags,
                    entry.notes,
                    metadata,
                    vuln.id
                ))
            else:
                # Insert new entry
                cursor.execute('''
                INSERT INTO vulnerabilities VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    vuln.id,
                    vuln.title,
                    vuln.description,
                    vuln.severity.value,
                    vuln.cvss_score,
                    vuln.affected_component,
                    vuln.fix_version,
                    references,
                    sources,
                    entry.status.value,
                    affected_versions,
                    fixed_versions,
                    discovered_date,
                    published_date,
                    last_updated,
                    entry.exploitability_score,
                    entry.impact_score,
                    cwe_ids,
                    tags,
                    entry.notes,
                    metadata
                ))
        
        conn.commit()
        conn.close()
    
    async def search_vulnerabilities(self, query: VulnerabilityDatabaseQuery) -> List[VulnerabilityDatabaseEntry]:
        """
        Search for vulnerabilities in the database
        """
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        # Build SQL query
        sql = "SELECT * FROM vulnerabilities WHERE 1=1"
        params = []
        
        # Add query filters
        if query.cve_id:
            sql += " AND id LIKE ?"
            params.append(f"%{query.cve_id}%")
        
        if query.component:
            sql += " AND affected_component LIKE ?"
            params.append(f"%{query.component}%")
        
        if query.severity:
            placeholders = ", ".join(["?" for _ in query.severity])
            sql += f" AND severity IN ({placeholders})"
            params.extend([s.value for s in query.severity])
        
        if query.status:
            placeholders = ", ".join(["?" for _ in query.status])
            sql += f" AND status IN ({placeholders})"
            params.extend([s.value for s in query.status])
        
        if query.source:
            sql += " AND ("
            source_conditions = []
            for source in query.source:
                source_conditions.append("sources LIKE ?")
                params.append(f"%{source.value}%")
            sql += " OR ".join(source_conditions) + ")"
        
        if query.fixed_in_version:
            sql += " AND fixed_versions LIKE ?"
            params.append(f"%{query.fixed_in_version}%")
        
        if query.affected_in_version:
            sql += " AND affected_versions LIKE ?"
            params.append(f"%{query.affected_in_version}%")
        
        if query.published_after:
            sql += " AND published_date >= ?"
            params.append(query.published_after.isoformat())
        
        if query.published_before:
            sql += " AND published_date <= ?"
            params.append(query.published_before.isoformat())
        
        if query.tags:
            for tag in query.tags:
                sql += " AND tags LIKE ?"
                params.append(f"%{tag}%")
        
        if query.text_search:
            sql += " AND (title LIKE ? OR description LIKE ?)"
            params.extend([f"%{query.text_search}%", f"%{query.text_search}%"])
        
        # Add limit and offset
        sql += " ORDER BY cvss_score DESC LIMIT ? OFFSET ?"
        params.extend([query.limit, query.offset])
        
        # Execute query
        cursor.execute(sql, params)
        rows = cursor.fetchall()
        
        # Convert rows to VulnerabilityDatabaseEntry objects
        results = []
        for row in rows:
            # Parse JSON fields
            references = json.loads(row["references"])
            sources = [VulnerabilitySource(s) for s in json.loads(row["sources"])]
            affected_versions = json.loads(row["affected_versions"])
            fixed_versions = json.loads(row["fixed_versions"])
            cwe_ids = json.loads(row["cwe_ids"])
            tags = set(json.loads(row["tags"]))
            metadata = json.loads(row["metadata"])
            
            # Create Vulnerability object
            vuln = Vulnerability(
                id=row["id"],
                title=row["title"],
                description=row["description"],
                severity=SeverityLevel(row["severity"]),
                cvss_score=row["cvss_score"],
                affected_component=row["affected_component"],
                fix_version=row["fix_version"],
                references=references
            )
            
            # Parse date fields
            discovered_date = datetime.fromisoformat(row["discovered_date"]) if row["discovered_date"] else None
            published_date = datetime.fromisoformat(row["published_date"]) if row["published_date"] else None
            last_updated = datetime.fromisoformat(row["last_updated"])
            
            # Create VulnerabilityDatabaseEntry object
            entry = VulnerabilityDatabaseEntry(
                vulnerability=vuln,
                sources=sources,
                status=VulnerabilityStatus(row["status"]),
                affected_versions=affected_versions,
                fixed_versions=fixed_versions,
                discovered_date=discovered_date,
                published_date=published_date,
                last_updated=last_updated,
                exploitability_score=row["exploitability_score"],
                impact_score=row["impact_score"],
                cwe_ids=cwe_ids,
                tags=tags,
                notes=row["notes"],
                metadata=metadata
            )
            
            results.append(entry)
        
        conn.close()
        return results
    
    async def get_vulnerability(self, vuln_id: str) -> Optional[VulnerabilityDatabaseEntry]:
        """
        Get a specific vulnerability by ID
        """
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute("SELECT * FROM vulnerabilities WHERE id = ?", (vuln_id,))
        row = cursor.fetchone()
        
        if not row:
            conn.close()
            return None
        
        # Parse JSON fields
        references = json.loads(row["references"])
        sources = [VulnerabilitySource(s) for s in json.loads(row["sources"])]
        affected_versions = json.loads(row["affected_versions"])
        fixed_versions = json.loads(row["fixed_versions"])
        cwe_ids = json.loads(row["cwe_ids"])
        tags = set(json.loads(row["tags"]))
        metadata = json.loads(row["metadata"])
        
        # Create Vulnerability object
        vuln = Vulnerability(
            id=row["id"],
            title=row["title"],
            description=row["description"],
            severity=SeverityLevel(row["severity"]),
            cvss_score=row["cvss_score"],
            affected_component=row["affected_component"],
            fix_version=row["fix_version"],
            references=references
        )
        
        # Parse date fields
        discovered_date = datetime.fromisoformat(row["discovered_date"]) if row["discovered_date"] else None
        published_date = datetime.fromisoformat(row["published_date"]) if row["published_date"] else None
        last_updated = datetime.fromisoformat(row["last_updated"])
        
        # Create VulnerabilityDatabaseEntry object
        entry = VulnerabilityDatabaseEntry(
            vulnerability=vuln,
            sources=sources,
            status=VulnerabilityStatus(row["status"]),
            affected_versions=affected_versions,
            fixed_versions=fixed_versions,
            discovered_date=discovered_date,
            published_date=published_date,
            last_updated=last_updated,
            exploitability_score=row["exploitability_score"],
            impact_score=row["impact_score"],
            cwe_ids=cwe_ids,
            tags=tags,
            notes=row["notes"],
            metadata=metadata
        )
        
        conn.close()
        return entry
    
    async def get_database_stats(self) -> VulnerabilityDatabaseStats:
        """
        Get statistics about the vulnerability database
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Get total count
        cursor.execute("SELECT COUNT(*) FROM vulnerabilities")
        total_entries = cursor.fetchone()[0]
        
        # Get counts by severity
        by_severity = {}
        for severity in SeverityLevel:
            cursor.execute("SELECT COUNT(*) FROM vulnerabilities WHERE severity = ?", (severity.value,))
            by_severity[severity] = cursor.fetchone()[0]
        
        # Get counts by status
        by_status = {}
        for status in VulnerabilityStatus:
            cursor.execute("SELECT COUNT(*) FROM vulnerabilities WHERE status = ?", (status.value,))
            by_status[status] = cursor.fetchone()[0]
        
        # Get counts by source
        by_source = {}
        for source in VulnerabilitySource:
            cursor.execute("SELECT COUNT(*) FROM vulnerabilities WHERE sources LIKE ?", (f"%{source.value}%",))
            by_source[source] = cursor.fetchone()[0]
        
        # Get last update time
        cursor.execute("SELECT MAX(last_update) FROM database_updates")
        last_updated_str = cursor.fetchone()[0]
        last_updated = datetime.fromisoformat(last_updated_str) if last_updated_str else datetime.utcnow()
        
        conn.close()
        
        return VulnerabilityDatabaseStats(
            total_entries=total_entries,
            by_severity=by_severity,
            by_status=by_status,
            by_source=by_source,
            last_updated=last_updated
        )
    
    async def update_vulnerability_status(self, vuln_id: str, status: VulnerabilityStatus, notes: Optional[str] = None) -> bool:
        """
        Update the status of a vulnerability
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Check if vulnerability exists
        cursor.execute("SELECT id FROM vulnerabilities WHERE id = ?", (vuln_id,))
        if not cursor.fetchone():
            conn.close()
            return False
        
        # Update status
        update_data = {
            "status": status.value,
            "last_updated": datetime.utcnow().isoformat()
        }
        
        if notes:
            update_data["notes"] = notes
        
        # Build update query
        set_clause = ", ".join([f"{key} = ?" for key in update_data.keys()])
        params = list(update_data.values())
        params.append(vuln_id)
        
        cursor.execute(f"UPDATE vulnerabilities SET {set_clause} WHERE id = ?", params)
        conn.commit()
        conn.close()
        
        return True
    
    async def add_custom_vulnerability(self, entry: VulnerabilityDatabaseEntry) -> bool:
        """
        Add a custom vulnerability to the database
        """
        # Set source to INTERNAL if not specified
        if not entry.sources:
            entry.sources = [VulnerabilitySource.INTERNAL]
        
        # Set last_updated to now
        entry.last_updated = datetime.utcnow()
        
        # Save to database
        await self._save_vulnerabilities([entry])
        return True
    
    async def _update_from_osint(self) -> Dict:
        """
        Update vulnerability database from OSINT (Open Source Intelligence) sources
        
        This method aggregates vulnerability data from various open source feeds:
        - VulDB: https://vuldb.com/
        - Exploit-DB: https://www.exploit-db.com/
        - SecurityFocus: https://www.securityfocus.com/
        - Full Disclosure: https://seclists.org/fulldisclosure/
        - MITRE CVE: https://cve.mitre.org/
        - OSV: https://osv.dev/
        - VulnDB: https://vulndb.cyberriskanalytics.com/
        """
        try:
            # Get the last update time for OSINT
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT last_update FROM database_updates WHERE source = ?", (VulnerabilitySource.OSINT,))
            row = cursor.fetchone()
            conn.close()
            
            last_update = datetime.fromisoformat(row[0]) if row else datetime.utcnow() - timedelta(days=30)
            days_back = (datetime.utcnow() - last_update).days + 1  # Add 1 day for overlap
            
            # Create tasks for each OSINT source
            update_tasks = [
                self._update_from_vuldb(last_update),
                self._update_from_exploit_db(last_update),
                self._update_from_security_focus(last_update),
                self._update_from_full_disclosure(last_update),
                self._update_from_mitre_cve(days_back),
                self._update_from_osv(days_back),
                self._update_from_vulndb(days_back)
            ]
            
            # Run updates concurrently
            results = await asyncio.gather(*update_tasks, return_exceptions=True)
            
            # Process results
            total_count = 0
            source_stats = {}
            
            source_names = [
                "vuldb", "exploit-db", "securityfocus", "fulldisclosure", 
                "mitre-cve", "osv", "vulndb"
            ]
            
            for i, result in enumerate(results):
                source_name = source_names[i]
                
                if isinstance(result, Exception):
                    logger.error(f"Error updating from {source_name}", error=str(result))
                    source_stats[source_name] = {"status": "error", "error": str(result)}
                else:
                    source_stats[source_name] = result
                    total_count += result.get("count", 0)
            
            return {
                "status": "success",
                "count": total_count,
                "source": VulnerabilitySource.OSINT,
                "sources": source_stats
            }
        
        except Exception as e:
            logger.error("Error updating from OSINT", error=str(e))
            return {"status": "error", "message": str(e)}
    
    async def _update_from_mitre_cve(self, days_back: int) -> Dict:
        """
        Update vulnerability database from MITRE CVE database
        """
        try:
            # Initialize the MITRE CVE integration
            mitre_integration = CVEMitreIntegration()
            
            # Fetch recent CVEs
            vulnerabilities = await mitre_integration.fetch_recent_cves(days_back=days_back)
            
            # Save to database
            await self._save_vulnerabilities(vulnerabilities)
            
            return {
                "status": "success",
                "count": len(vulnerabilities),
                "source": "mitre-cve"
            }
        
        except Exception as e:
            logger.error("Error updating from MITRE CVE", error=str(e))
            return {"status": "error", "message": str(e), "count": 0}
    
    async def _update_from_osv(self, days_back: int) -> Dict:
        """
        Update vulnerability database from OSV (Open Source Vulnerabilities)
        """
        try:
            # Initialize the OSV integration
            osv_integration = OSVIntegration()
            
            # Fetch recent vulnerabilities
            vulnerabilities = await osv_integration.fetch_recent_vulnerabilities(days_back=days_back)
            
            # Save to database
            await self._save_vulnerabilities(vulnerabilities)
            
            return {
                "status": "success",
                "count": len(vulnerabilities),
                "source": "osv"
            }
        
        except Exception as e:
            logger.error("Error updating from OSV", error=str(e))
            return {"status": "error", "message": str(e), "count": 0}
    
    async def _update_from_vulndb(self, days_back: int) -> Dict:
        """
        Update vulnerability database from VulnDB
        """
        try:
            # Initialize the VulnDB integration
            vulndb_integration = VulnDBIntegration()
            
            # Check if API key is configured
            if not self.settings.vulndb_api_key:
                return {"status": "skipped", "reason": "VulnDB API key not configured", "count": 0}
            
            # Fetch recent vulnerabilities
            vulnerabilities = await vulndb_integration.fetch_recent_vulnerabilities(days_back=days_back)
            
            # Save to database
            await self._save_vulnerabilities(vulnerabilities)
            
            return {
                "status": "success",
                "count": len(vulnerabilities),
                "source": "vulndb"
            }
        
        except Exception as e:
            logger.error("Error updating from VulnDB", error=str(e))
            return {"status": "error", "message": str(e), "count": 0}
    
    async def _update_from_vuldb(self, last_update: datetime) -> Dict:
        """
        Update from VulDB (https://vuldb.com/)
        """
        try:
            # VulDB API endpoint
            api_url = "https://vuldb.com/api/v1/search"
            
            # VulDB API parameters
            params = {
                "modificationdate": last_update.strftime("%Y-%m-%d"),
                "details": "yes"
            }
            
            # VulDB API headers
            headers = {
                "X-VulDB-ApiKey": self.settings.vuldb_api_key,
                "Content-Type": "application/json"
            }
            
            # Skip if API key is not configured
            if not self.settings.vuldb_api_key:
                return {"status": "skipped", "reason": "VulDB API key not configured", "count": 0}
            
            # Fetch data from VulDB
            async with aiohttp.ClientSession() as session:
                async with session.post(api_url, json=params, headers=headers) as response:
                    if response.status != 200:
                        return {"status": "error", "message": f"VulDB API returned status {response.status}", "count": 0}
                    
                    data = await response.json()
                    result = data.get("result", [])
                    
                    # Process vulnerabilities
                    vulnerabilities = []
                    for entry in result:
                        # Extract CVE ID
                        sources = entry.get("source", {})
                        cve_id = sources.get("cve", {}).get("id")
                        
                        # Skip if no CVE ID
                        if not cve_id:
                            continue
                        
                        # Extract basic information
                        title = entry.get("title", {}).get("text", "")
                        description = entry.get("description", {}).get("text", "")
                        
                        # Extract CVSS information
                        cvss = entry.get("cvss3", {})
                        base_score = float(cvss.get("score", 0))
                        
                        # Map severity
                        severity = SeverityLevel.UNKNOWN
                        if base_score >= 9.0:
                            severity = SeverityLevel.CRITICAL
                        elif base_score >= 7.0:
                            severity = SeverityLevel.HIGH
                        elif base_score >= 4.0:
                            severity = SeverityLevel.MEDIUM
                        elif base_score > 0:
                            severity = SeverityLevel.LOW
                        
                        # Extract references
                        references = []
                        for ref_type, ref_data in entry.get("references", {}).items():
                            if isinstance(ref_data, list):
                                for ref in ref_data:
                                    if isinstance(ref, dict) and "url" in ref:
                                        references.append(ref["url"])
                        
                        # Extract affected products
                        affected_component = ""
                        affected_versions = []
                        for product in entry.get("entry", {}).get("products", []):
                            if product.get("type") == "software":
                                affected_component = product.get("name", "")
                                affected_versions = [product.get("version", "")]
                                break
                        
                        # Create vulnerability entry
                        vuln = Vulnerability(
                            id=cve_id,
                            title=title,
                            description=description,
                            severity=severity,
                            cvss_score=base_score,
                            affected_component=affected_component,
                            references=references
                        )
                        
                        # Create database entry
                        entry = VulnerabilityDatabaseEntry(
                            vulnerability=vuln,
                            sources=[VulnerabilitySource.OSINT],
                            status=VulnerabilityStatus.ACTIVE,
                            affected_versions=affected_versions,
                            published_date=datetime.fromtimestamp(int(entry.get("entry", {}).get("date", 0))),
                            last_updated=datetime.utcnow(),
                            tags={"vuldb"}
                        )
                        
                        vulnerabilities.append(entry)
                    
                    # Save to database
                    await self._save_vulnerabilities(vulnerabilities)
                    
                    return {
                        "status": "success",
                        "count": len(vulnerabilities)
                    }
        
        except Exception as e:
            logger.error("Error updating from VulDB", error=str(e))
            return {"status": "error", "message": str(e), "count": 0}
    
    async def _update_from_exploit_db(self, last_update: datetime) -> Dict:
        """
        Update from Exploit-DB (https://www.exploit-db.com/)
        """
        try:
            # Exploit-DB CSV URL
            csv_url = "https://www.exploit-db.com/file_download/public/exploits.csv"
            
            # Fetch data from Exploit-DB
            async with aiohttp.ClientSession() as session:
                async with session.get(csv_url) as response:
                    if response.status != 200:
                        return {"status": "error", "message": f"Exploit-DB returned status {response.status}", "count": 0}
                    
                    csv_data = await response.text()
                    
                    # Parse CSV data
                    import csv
                    from io import StringIO
                    
                    reader = csv.DictReader(StringIO(csv_data))
                    
                    # Process vulnerabilities
                    vulnerabilities = []
                    for row in reader:
                        # Extract date
                        date_str = row.get("date", "")
                        try:
                            published_date = datetime.strptime(date_str, "%Y-%m-%d")
                        except ValueError:
                            published_date = datetime.utcnow()
                        
                        # Skip if published before last update
                        if published_date < last_update:
                            continue
                        
                        # Extract CVE ID
                        cve_id = row.get("cve", "")
                        
                        # Skip if no CVE ID
                        if not cve_id:
                            continue
                        
                        # Extract basic information
                        title = row.get("description", "")
                        description = f"Exploit-DB ID: {row.get('id', '')}\n{title}"
                        
                        # Extract references
                        references = [f"https://www.exploit-db.com/exploits/{row.get('id', '')}"]
                        
                        # Extract affected component
                        affected_component = row.get("app", "")
                        
                        # Create vulnerability entry
                        vuln = Vulnerability(
                            id=cve_id,
                            title=title,
                            description=description,
                            severity=SeverityLevel.HIGH,  # Default to HIGH for exploits
                            cvss_score=7.5,  # Default score
                            affected_component=affected_component,
                            references=references
                        )
                        
                        # Create database entry
                        entry = VulnerabilityDatabaseEntry(
                            vulnerability=vuln,
                            sources=[VulnerabilitySource.OSINT],
                            status=VulnerabilityStatus.ACTIVE,
                            published_date=published_date,
                            last_updated=datetime.utcnow(),
                            tags={"exploit-db", "exploit"}
                        )
                        
                        vulnerabilities.append(entry)
                    
                    # Save to database
                    await self._save_vulnerabilities(vulnerabilities)
                    
                    return {
                        "status": "success",
                        "count": len(vulnerabilities)
                    }
        
        except Exception as e:
            logger.error("Error updating from Exploit-DB", error=str(e))
            return {"status": "error", "message": str(e), "count": 0}
    
    async def _update_from_security_focus(self, last_update: datetime) -> Dict:
        """
        Update from SecurityFocus (https://www.securityfocus.com/)
        
        Note: This is a simplified implementation as SecurityFocus doesn't provide a public API.
        In a real implementation, this would involve web scraping or using a third-party API.
        """
        # For demonstration purposes, we'll return a placeholder
        return {
            "status": "skipped",
            "reason": "SecurityFocus integration requires web scraping",
            "count": 0
        }
    
    async def _update_from_full_disclosure(self, last_update: datetime) -> Dict:
        """
        Update from Full Disclosure (https://seclists.org/fulldisclosure/)
        
        Note: This is a simplified implementation as Full Disclosure doesn't provide a public API.
        In a real implementation, this would involve parsing the mailing list archives.
        """
        # For demonstration purposes, we'll return a placeholder
        return {
            "status": "skipped",
            "reason": "Full Disclosure integration requires mailing list parsing",
            "count": 0
        }
